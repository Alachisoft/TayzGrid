/*
* Copyright (c) 2015, Alachisoft. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

package com.alachisoft.tayzgrid.common.net;

import com.alachisoft.tayzgrid.serialization.core.io.ICompactSerializable;
import com.alachisoft.tayzgrid.serialization.core.io.InternalCompactSerializable;
import com.alachisoft.tayzgrid.serialization.core.io.CacheObjectInput;
import com.alachisoft.tayzgrid.serialization.core.io.CacheObjectOutput;
import com.alachisoft.tayzgrid.serialization.standard.io.CompactReader;
import com.alachisoft.tayzgrid.serialization.standard.io.CompactWriter;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectInputStream;
import java.io.ObjectOutput;
import java.io.ObjectOutputStream;
import java.io.Serializable;
import java.net.Inet4Address;
import java.net.InetAddress;
import java.net.UnknownHostException;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * Abstract address. Used to identify members on a group to send messages to. Addresses are mostly generated by the bottom-most (transport) layers (e.g. UDP, TCP, LOOPBACK).
 * Subclasses need to implement the following methods: <ul> <li>isMultiCastAddress() <li>equals() <li>hashCode() <li>compareTo() </ol>
 *
 * <author> Bela Ban </author>
 */
public class Address implements Cloneable, java.lang.Comparable, ICompactSerializable, Serializable
{

    private InetAddress ip_addr;
    private int port;
    private byte[] additional_data;
    public static boolean resolve_dns = false;

    public Address()
    {
    }

    public Address(String i, int p) throws UnknownHostException
    {
        try
        {
            ip_addr = Resolve(i);
        }
        catch (RuntimeException e)
        {
            try
            {
                ip_addr = Resolve("127.0.0.1");
            }
            catch (RuntimeException ex)
            {
            }
        }
        port = p;
    }

    public Address(InetAddress i, int p)
    {
        ip_addr = i;
        port = p;
    }

    public Address(int port) throws UnknownHostException
    {
        try
        {

            ip_addr = Resolve(InetAddress.getLocalHost().getHostAddress());
            this.port = port;
        }
        catch (RuntimeException e)
        {
        }
    }

    public final InetAddress getIpAddress()
    {
        return ip_addr;
    }

    public final int getPort()
    {
        return port;
    }

    public final boolean getMulticastAddress()
    {
        return ip_addr != null ? isMulticastAddress(ip_addr) : false;
    }

    public final byte[] getAdditionalData()
    {
        return additional_data;
    }

    public final void setAdditionalData(byte[] value)
    {
        this.additional_data = value;
    }

    public static InetAddress Resolve(String addr) throws UnknownHostException
    {
        InetAddress ip = null;
        try
        {
            ip = InetAddress.getByName(addr);//Address(addr.getBytes());
        }
        catch (RuntimeException e)
        {
            ip = DnsCache.ResolveName(addr);
        }
        return ip;
    }

    /**
     * Establishes an order between 2 addresses. Assumes other contains non-null Address. Excludes channel_name from comparison.
     *
     * @return 0 for equality, value less than 0 if smaller, greater than 0 if greater.
     *
     */
    public final int compare(Address other)
    {
        return this.compareTo(other);
    }

    /**
     * implements the java.lang.Comparable interface
     *
     * @see java.lang.Comparable
     *
     * @param o - the Object to be compared
     *
     * @return a negative integer, zero, or a positive integer as this object is less than, equal to, or greater than the specified object.
     *
     * @exception java.lang.ClassCastException - if the specified object's type prevents it from being compared to this Object.
     *
     */
    public final int compareTo(Object o)
    {
        int h1 = 0, h2 = 0, rc;

        if ((o == null)) 
        {
            return 1;
        }
        Address other = (Address) ((o instanceof Address) ? o : null);
        if (other == null)
        {
            return 1;
        }
        if (ip_addr == null)
        {
            if (other.ip_addr == null)
            {
                return port < other.port ? - 1 : (port > other.port ? 1 : 0);
            }
            else
            {
                return -1;
            }
        }


        h1 = ip_addr.hashCode();
        if (other.ip_addr != null)
        {
            h2 = other.ip_addr.hashCode();
        }
        rc = h1 < h2 ? - 1 : (h1 > h2 ? 1 : 0);
        return rc != 0 ? rc : (port < other.port ? - 1 : (port > other.port ? 1 : 0));
    }

    @Override
    public boolean equals(Object obj)
    {
        if (obj == null)
        {
            return false;
        }
        return this.compareTo(obj) == 0 ? true : false;
    }

    @Override
    public int hashCode()
    {
        int retval = ip_addr != null ? ip_addr.hashCode() + port : port;
        return retval;
    }

    @Override
    public String toString()
    {
        StringBuilder sb = new StringBuilder();

        if (ip_addr == null)
        {
            sb.append("<null>");
        }
        else
        {
            if (ip_addr.isMulticastAddress()) // Love java for this
            {
                sb.append(ip_addr.getHostAddress());
            }
            else
            {
                String host_name = null;
                if (resolve_dns)
                {
                    try
                    {
                        host_name = DnsCache.ResolveAddress(ip_addr);
                    }
                    catch (UnknownHostException ex)
                    {
                        Logger.getLogger(Address.class.getName()).log(Level.SEVERE, null, ex);
                    }
                }
                else
                {
                    host_name = ip_addr.getHostAddress(); //Love java for this too
                }
                appendShortName(host_name, sb);
            }
        }
        sb.append(":" + port);
        return sb.toString();
    }

    /**
     * Input: "daddy.nms.fnc.fujitsu.com", output: "daddy". Appends result to string buffer 'sb'.
     *
     * @param hostname The hostname in long form. Guaranteed not to be null
     *
     * @param sb The string buffer to which the result is to be appended
     *
     */
    private void appendShortName(String hostname, StringBuilder sb)
    {
        int index = hostname.indexOf((char) '.');

        if (hostname == null)
        {
            return;
        }
        if (index > 0 && !Character.isDigit(hostname.charAt(0)))
        {
            sb.append(hostname.substring(0, (index) - (0)));
        }
        else
        {
            sb.append(hostname);
        }
    }

    public final Object clone()
    {
        Address ret = null;
        try
        {
            ret = new Address(ip_addr.getHostAddress(), port);
        }
        catch (UnknownHostException ex)
        {
            Logger.getLogger(Address.class.getName()).log(Level.SEVERE, null, ex);
        }
        if (additional_data != null)
        {
            ret.additional_data = new byte[additional_data.length];
            System.arraycopy(additional_data, 0, ret.additional_data, 0, additional_data.length);
        }

        return ret;
    }

    /**
     * Converts an IP address in string to an equivalent byte array.
     *
     * @param ipaddr
     * @return byte[] of IP address if ip is valid otherwise null
     */
    private static byte[] ParseIPAddress(String ipaddr)
    {
        byte[] address = null;
        String[] mcast = ipaddr.split("[.]", -1);

        if (mcast.length == 4)
        {
            address = new byte[4];
            try
            {
                address[0] = (byte) (Integer.parseInt(mcast[0]));
                address[1] = (byte) (Integer.parseInt(mcast[1]));
                address[2] = (byte) (Integer.parseInt(mcast[2]));
                address[3] = (byte) (Integer.parseInt(mcast[3]));
            }
            catch (RuntimeException e)
            {
                return null;
            }
        }
        return address;
    }

    /**
     * Checks if a specified string is a valid multi-cast ip-address.
     *
     * @param ipaddr
     * @return
     */
    public static boolean isMulticastAddress(String ipaddr)
    {
        try
        {
            return isMulticastAddress(ParseIPAddress(ipaddr));
        }
        catch (RuntimeException e)
        {
            return false;
        }

    }

    public static boolean isMulticastAddress(InetAddress ipAddr)
    {
        if (ipAddr != null)
        {
            String[] mcast = ipAddr.toString().split("[.]", -1);
            byte b1 = Byte.parseByte(mcast[0]);
            byte b2 = Byte.parseByte(mcast[1]);
            byte b3 = Byte.parseByte(mcast[2]);
            byte b4 = Byte.parseByte(mcast[3]);

            if ((b1 < 224) || (b1 > 240))
            {
                return false;
            }
            if ((b1 == 224) && (b3 < 1))
            {
                return false;
            }

            return true;
        }
        return false;
    }

    /**
     * Checks if the specified IP address in byte[] array is a valid IP multicast Address.
     *
     * @param ipAddr
     * @return
     */
    private static boolean isMulticastAddress(byte[] ipAddr)
    {
        if (ipAddr != null && ipAddr.length == 4)
        {
            if ((ipAddr[0] < 224) || (ipAddr[0] > 240))
            {
                return false;
            }
            if ((ipAddr[0] == 224) && (ipAddr[2] < 1))
            {
                return false;
            }

            return true;
        }
        return false;
    }

    public final void DeserializeLocal(ObjectInput reader) throws UnknownHostException, IOException
    {
        int bytesToRead = reader.readInt();
        if (bytesToRead > 0)
        {
            byte[] ip = new byte[bytesToRead];
            reader.read(ip, 0, bytesToRead);
            if (ip != null)
            {
                try
                {
                    ip_addr = InetAddress.getByAddress(ip);

                }
                catch (Exception e)
                {
                }
            }
        }

        port = reader.readInt();

        bytesToRead = reader.readInt();
        if (bytesToRead > 0)
        {
            additional_data = new byte[bytesToRead];
            reader.read(additional_data, 0, bytesToRead);
        }
    }

    public final void SerializeLocal(ObjectOutput writer) throws IOException
    {
byte[] ip = ip_addr != null ? ParseIPAddress(ip_addr.getHostAddress()) : null;

        if (ip != null)
        {
            writer.writeInt(ip.length);
            writer.write(ip);
        }
        else
        {
            writer.writeInt(0);
        }

        writer.writeInt(port);

        if (additional_data != null)
        {
            writer.writeInt(additional_data.length);
            writer.write(additional_data);
        }
        else
        {
            writer.writeInt(0);
        }
    }

    public final void deserialize(CacheObjectInput reader) throws ClassNotFoundException, IOException
    {
        byte[] ip = (byte[]) reader.readObject();
        if (ip != null)
        {
            try
            {
                ip_addr = InetAddress.getByAddress(ip);
            }
            catch (Exception e)
            {
            }
        }
        port = reader.readInt();
        additional_data = (byte[]) reader.readObject();
    }

    public void serialize(CacheObjectOutput writer) throws IOException
    {
        byte[] ip = ip_addr != null ? ParseIPAddress(ip_addr.getHostAddress()) : null;
        writer.writeObject(ip);
        writer.writeInt(port);
        writer.writeObject(additional_data);
    }

    public void Serialize(CompactWriter writer) throws IOException
    {
        byte[] ip = ip_addr != null ? ParseIPAddress(ip_addr.getHostAddress()) : null;
        writer.WriteObject(ip);
        writer.Write(port);
        writer.WriteObject(additional_data);
    }

    public void Deserialize(CompactReader reader) throws IOException, ClassNotFoundException
    {
        byte[] ip = (byte[]) reader.ReadObject();
        if (ip != null)
        {
            try
            {
                ip_addr = InetAddress.getByAddress(ip);
            }
            catch (Exception e)
            {
            }
        }
        port = reader.ReadInt32();
        additional_data = (byte[]) reader.ReadObject();
    }

    public static Address Parse(String address) throws UnknownHostException
    {
        String[] hostPort = address.split("[:]", -1);
        return new Address(hostPort[0], Integer.parseInt(hostPort[1]));
    }
}
