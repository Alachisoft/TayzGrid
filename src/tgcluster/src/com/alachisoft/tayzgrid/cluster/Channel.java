/*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

package com.alachisoft.tayzgrid.cluster;

import com.alachisoft.tayzgrid.cluster.stack.PerfStatsCollector;
import com.alachisoft.tayzgrid.common.net.Address;

/**
 * Abstract class for any implementation of a channel <p><b>Author:</b> Chris Koiak, Bela Ban</p> <p><b>Date:</b> 12/03/2003</p>
 */
public abstract class Channel implements Transport
{

    public static final int BLOCK = 0;
    //public const int VIEW = 1;
    public static final int SUSPECT = 2;
    public static final int LOCAL = 3;
    public static final int GET_STATE_EVENTS = 4;
    public static final int AUTO_RECONNECT = 5;
    public static final int AUTO_GETSTATE = 6;
    /**
     * All events will be sent to this class once received.
     */
    protected UpHandler up_handler = null;
    /**
     * Allows listening on the channel. The listener will be notified of channel closing, etc.
     */
    protected ChannelListener channel_listener = null;

    /**
     * Constructor: Uses predefined stack.
     */
    protected Channel()
    {
    }

    /**
     * Constructor: Stack and properties are specified
     *
     * @param properties Properties of Channel stack
     */
    protected Channel(Object properties)
    {
    }

    //<editor-fold defaultstate="collapsed" desc="properties">
    /**
     * Determines whether the channel is open, ie. the protocol stack has been created (may not be connected though).
     */
    public abstract boolean getIsOpen();

    /**
     * Determines whether the channel is connected to a group. This implies it is open. If true is returned, then the channel can be used to send and receive messages.
     */
    public abstract boolean getIsConnected();

    /**
     * Returns the number of messages that are waiting. Those messages can be removed by {@link #receive(long)}. Note that this number could change after calling this method and
     * before calling <tt>receive()</tt> (e.g. the latter method might be called by a different thread).
     *
     * @return The number of messages on the queue, or -1 if the queue/channel is closed/disconnected.
     *
     */
    public int getNumMessages()
    {
        return - 1;
    }

    /**
     * Gets the current view. This does <em>not</em> retrieve a new view, use
     * <code>receive()</code> to do so. The view may only be available after a successful
     * <code>connect()</code>. The result of calling this method on an unconnected channel is implementation defined (may return null). Calling it on a channel that is not enabled
     * to receive view events (via
     * <code>setOpt</code>) returns
     * <code>null</code>. Calling this method on a closed channel returns a null view.
     *
     * @return The current view.
     *
     */
    public abstract View getView();

    /**
     * Returns the channel's own address. The result of calling this method on an unconnected channel is implementation defined (may return null). Calling this method on a closed
     * channel returns null.
     *
     * @return The channel's address. Generated by the underlying transport, and opaque. Addresses can be used as destination in the
     * <code>Send</code> operation.
     *
     */
    public abstract Address getLocalAddress();

    /**
     * Returns the group address of the group of which the channel is a member. This is the object that was the argument to
     * <code>Connect</code>. Calling this method on a closed channel returns
     * <code>null</code>.
     *
     * @return The group address
     *
     */
    public abstract String getChannelName();

    /**
     * When up_handler is set, all events will be passed to it directly. These will not be received by the channel (except connect/disconnect, state retrieval and the like). This
     * can be used by building blocks on top of a channel; thus the channel is used as a pass-through medium, and the building blocks take over some of the channel's tasks.
     * However, tasks such as connection management and state transfer is still handled by the channel.
     */
    public void setUpHandler(UpHandler value)
    {
        this.up_handler = value;
    }

    /**
     * Allows to be notified when a channel event such as connect, disconnect or close occurs. E.g. a PullPushAdapter may choose to stop when the channel is closed, or to start
     * when it is opened.
     */
    public void setChannelListener(ChannelListener value)
    {
        this.channel_listener = value;
    }
    //</editor-fold>

    /**
     * Connects the Channel to a group.
     *
     * @param channel_name Group to connect to (or create).
     */
    public abstract void connect(String channel_name, String subGroup_name, boolean isStartedAsMirror, boolean twoPhaseInitialization) throws ChannelException;

    public abstract void connectPhase2()throws ChannelClosedException, ChannelException;

    /**
     * Disconnects the Channel from the group
     */
    public abstract void disconnect();

    /**
     * Disconnects and closes the Channel.
     */
    public abstract void close() throws InterruptedException;

    /**
     * Re-opens a closed channel.
     * @throws ChannelException
     */
    public abstract void open() throws  ChannelException;

    /**
     * Sends a message through the Channel
     *
     * @param msg Message to be sent
     * @throws ChannelClosedException
     * @throws ChannelException
     */
    @Override
    public abstract void send(Message msg)throws ChannelClosedException, ChannelException;

    /**
     * Helper method. Will create a Message(dst, src, obj) and use send(Message).
     *
     * @param dst Destination address for message. If null, message will be sent to all current group members
     *
     * @param src Source (sender's) address. If null, it will be set by the protocol's transport layer before being put on the wire. Can usually be set to null.
     *
     * @param obj Serializable object. Will be serialized into the byte buffer of the Message. If it is <em> not</em> serializable, the byte buffer will be null.
     *
     */
    public abstract void send(Address dst, Address src, Object obj)throws ChannelClosedException, ChannelException;

    /**
     * Passes an event down the protocol stack
     *
     * @param evt Event to be passed down the stack
     */
    public void down(Event evt)
    {
    }

    /**
     * Receives an event from the channel
     *
     * @param timeout Time (ms) to wait for a message
     * @return The next Event received by the channel
     * @throws ChannelClosedException
     * @throws ChannelException
     */
    @Override
    public abstract Object receive(long timeout) throws ChannelClosedException,ChannelException;

    /**
     * Performs the same as <c>receive()</c> but does not remove the Event
     *
     * @param timeout Time (ms) to wait for a message
     * @return The next Event received by the channel
     */
    public abstract Event peek(long timeout) throws ChannelClosedException, ChannelException;

    /**
     * Sets a variety of options within the channel
     *
     * @param option The string representation of the option
     * @param value The value that the option should be set to
     */
    public abstract void setOpt(int option, Object value);

    /**
     * Gets an option. This method can be called on an unconnected channel. Calling this method on a closed channel returns
     * <code>null</code>.
     *
     * @param option The option to be returned.
     *
     * @return The object associated with an option.
     *
     */
    public abstract Object getOpt(int option);

    /**
     * Called to acknowledge a block() (callback in
     * <code>MembershipListener</code> or
     * <code>BlockEvent</code> received from call to
     * <code>Receive</code>). After sending BlockOk, no messages should be sent until a new view has been received. Calling this method on a closed channel has no effect.
     */
    public abstract void blockOk();

    /**
     * Get cluster stat collector instance to get values to publish on wmis
     */
    //: No support for Perfstat
    //public abstract PerfStatsCollector getClusterStatCollector();

    public static String option2String(int option)
    {
        switch (option)
        {
            case BLOCK:
                return "BLOCK";

            case SUSPECT:
                return "SUSPECT";
            case LOCAL:
                return "LOCAL";
            case GET_STATE_EVENTS:
                return "GET_STATE_EVENTS";
            case AUTO_RECONNECT:
                return "AUTO_RECONNECT";
            case AUTO_GETSTATE:
                return "AUTO_GETSTATE";
            default:
                return "unknown (" + option + ')';
        }
    }
}
